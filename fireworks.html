<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="robots" content="noindex,nofollow" />
  <title>Canvas Fireworks</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    .hud {
      position: fixed;
      left: 12px;
      bottom: 12px;
      color: rgba(255,255,255,0.75);
      font-size: 12px;
      line-height: 1.4;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 10px;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      pointer-events: none;
    }
    .hud strong { color: rgba(255,255,255,0.95); }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hud">
    <strong>花火</strong><br />
    ・自動で打ち上げ<br />
    ・画面タップ/クリックでも発射<br />
    ・文字花火も定期表示
  </div>

  <script>
    (() => {
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d", { alpha: false });

      let W = 0, H = 0, DPR = 1;

      function resize() {
        DPR = Math.min(2, window.devicePixelRatio || 1);
        W = Math.floor(window.innerWidth);
        H = Math.floor(window.innerHeight);
        canvas.width = Math.floor(W * DPR);
        canvas.height = Math.floor(H * DPR);
        canvas.style.width = W + "px";
        canvas.style.height = H + "px";
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        ctx.imageSmoothingEnabled = true;
      }
      window.addEventListener("resize", resize, { passive: true });
      resize();

      // ---- util ----
      const rand = (a, b) => a + Math.random() * (b - a);
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);

      // ---- physics / tuning ----
      const GRAVITY = 0.075;
      const AIR_DRAG = 0.985;
      const ROCKET_DRAG = 0.992;

      // ---- particle systems ----
      const fireworks = [];
      const particles = [];

      class Particle {
        constructor(x, y, vx, vy, hue, life, size, glow) {
          this.x = x; this.y = y;
          this.vx = vx; this.vy = vy;
          this.hue = hue;
          this.life = life;
          this.maxLife = life;
          this.size = size;
          this.glow = glow;
          this.twinkle = Math.random() < 0.35;
        }
        step() {
          this.vx *= AIR_DRAG;
          this.vy = this.vy * AIR_DRAG + GRAVITY;
          this.x += this.vx;
          this.y += this.vy;
          this.life -= 1;
        }
        draw(ctx) {
          const t = this.life / this.maxLife;
          const alpha = clamp(t, 0, 1);
          const flicker = this.twinkle ? (0.75 + 0.25 * Math.sin((this.maxLife - this.life) * 0.35)) : 1.0;

          ctx.globalAlpha = alpha * flicker;
          ctx.fillStyle = `hsla(${this.hue}, 100%, 60%, 1)`;

          if (this.glow) {
            ctx.shadowBlur = 12;
            ctx.shadowColor = `hsla(${this.hue}, 100%, 60%, 1)`;
          } else {
            ctx.shadowBlur = 0;
          }

          ctx.beginPath();
          ctx.arc(this.x, this.y, Math.max(0.7, this.size), 0, Math.PI * 2);
          ctx.fill();

          ctx.shadowBlur = 0;
          ctx.globalAlpha = 1;
        }
        get dead() { return this.life <= 0; }
      }

      class Firework {
        constructor(sx, sy, tx, ty, opts = {}) {
          this.sx = sx; this.sy = sy;
          this.x = sx; this.y = sy;
          this.tx = tx; this.ty = ty;

          const angle = Math.atan2(ty - sy, tx - sx);
          const d = dist(sx, sy, tx, ty);

          const speed = clamp(d / 18, 10, 22);
          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed;

          this.hue = (typeof opts.hue === "number") ? opts.hue : rand(0, 360);
          this.small = !!opts.small;

          this.trail = [];
          this.trailMax = this.small ? 10 : 14;
          this.exploded = false;
        }

        explode() {
          this.exploded = true;

          const baseHue = this.hue;

          // 通常花火
          const ring = !this.small && Math.random() < 0.35;
          const chrys = !this.small && Math.random() < 0.40;
          const crackle = !this.small && Math.random() < 0.30;

          // 文字用は軽め
          const count = this.small
            ? Math.floor(rand(18, 34))
            : Math.floor(rand(70, 140));

          for (let i = 0; i < count; i++) {
            const a = ring ? (i / count) * Math.PI * 2 : rand(0, Math.PI * 2);
            const sp = this.small
              ? rand(1.4, 3.2)
              : (chrys ? rand(2.8, 6.8) : rand(2.2, 7.6));

            const vx = Math.cos(a) * sp * rand(0.85, 1.15);
            const vy = Math.sin(a) * sp * rand(0.85, 1.15);

            const hue = (baseHue + rand(-18, 18) + (!this.small && Math.random() < 0.15 ? 60 : 0)) % 360;
            const life = this.small ? Math.floor(rand(22, 40)) : Math.floor(rand(45, 95));
            const size = this.small ? rand(0.9, 1.5) : rand(1.1, 2.2);

            particles.push(new Particle(this.x, this.y, vx, vy, hue, life, size, true));

            if (crackle && Math.random() < 0.18) {
              const vx2 = vx * rand(0.2, 0.55) + rand(-0.6, 0.6);
              const vy2 = vy * rand(0.2, 0.55) + rand(-0.6, 0.6);
              particles.push(new Particle(this.x, this.y, vx2, vy2, hue, Math.floor(rand(18, 32)), rand(0.8, 1.4), false));
            }
          }
        }

        step() {
          this.trail.push({ x: this.x, y: this.y });
          if (this.trail.length > this.trailMax) this.trail.shift();

          this.vx *= ROCKET_DRAG;
          this.vy = this.vy * ROCKET_DRAG - 0.015;
          this.x += this.vx;
          this.y += this.vy;

          const reached = dist(this.x, this.y, this.tx, this.ty) < (this.small ? 14 : 18);
          const peaked = this.vy >= -0.5 && this.y < this.sy - 120;

          if (!this.exploded && (reached || peaked)) {
            this.explode();
          }
        }

        draw(ctx) {
          ctx.save();
          ctx.globalCompositeOperation = "lighter";

          for (let i = 0; i < this.trail.length; i++) {
            const p = this.trail[i];
            const t = i / this.trail.length;
            ctx.globalAlpha = (0.05 + 0.35 * t);
            ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, 1)`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, (this.small ? 1.0 : 1.2) + (this.small ? 1.2 : 1.6) * t, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.globalAlpha = 1;
          ctx.shadowBlur = this.small ? 14 : 18;
          ctx.shadowColor = `hsla(${this.hue}, 100%, 70%, 1)`;
          ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, 1)`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.small ? 1.8 : 2.2, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }

        get dead() { return this.exploded; }
      }

      function launchTo(x, y, opts = {}) {
        const sx = rand(W * 0.2, W * 0.8);
        const sy = H + 10;
        const tx = clamp(x, 20, W - 20);
        const ty = clamp(y, 40, H * 0.80);
        fireworks.push(new Firework(sx, sy, tx, ty, opts));
      }

      function autoLaunch() {
        const x = rand(W * 0.15, W * 0.85);
        const y = rand(H * 0.12, H * 0.55);
        launchTo(x, y);
      }

      // input (tap/click)
      function pointerPos(e) {
        if (e.touches && e.touches[0]) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        if (e.changedTouches && e.changedTouches[0]) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
        return { x: e.clientX, y: e.clientY };
      }

      const onDown = (e) => {
        e.preventDefault();
        const p = pointerPos(e);
        const burst = Math.random() < 0.35 ? 2 : 1;
        for (let i = 0; i < burst; i++) {
          launchTo(p.x + rand(-40, 40), p.y + rand(-30, 30));
        }
      };

      canvas.addEventListener("mousedown", onDown);
      canvas.addEventListener("touchstart", onDown, { passive: false });

      // ---- text fireworks ----
      const textCanvas = document.createElement("canvas");
      const textCtx = textCanvas.getContext("2d");

      let textQueue = [];
      let nextTextLaunchAt = 0;

      function buildTextPoints() {
        textCanvas.width = W;
        textCanvas.height = H;

        textCtx.clearRect(0, 0, W, H);

        // 文字の配置（上寄り）
        const y1 = H * 0.26;
        const y2 = H * 0.40;

        // フォントサイズ（端末に合わせて）
        const size1 = clamp(H * 0.20, 72, 220);   // 2026
        const size2 = clamp(H * 0.085, 28, 90);   // Happy New Year

        textCtx.textAlign = "center";
        textCtx.textBaseline = "middle";

        // 少し太めにして点が拾いやすいように
        textCtx.fillStyle = "rgba(255,255,255,1)";

        textCtx.font = `800 ${Math.floor(size1)}px system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif`;
        textCtx.fillText("2026", W / 2, y1);

        textCtx.font = `800 ${Math.floor(size2)}px system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif`;
        textCtx.fillText("Happy New Year", W / 2, y2);

        const img = textCtx.getImageData(0, 0, W, H).data;

        // ピクセルの間引き（負荷対策）
        const step = clamp(Math.floor(Math.min(W, H) / 140), 4, 8);

        const points = [];
        for (let y = 0; y < H; y += step) {
          for (let x = 0; x < W; x += step) {
            const a = img[(y * W + x) * 4 + 3];
            if (a > 160) points.push({ x, y });
          }
        }

        // 点が多すぎると重いので上限をかける
        const maxPoints = 520;
        if (points.length > maxPoints) {
          // シャッフルしてランダムに抽出
          for (let i = points.length - 1; i > 0; i--) {
            const j = (Math.random() * (i + 1)) | 0;
            const tmp = points[i];
            points[i] = points[j];
            points[j] = tmp;
          }
          points.length = maxPoints;
        }

        return points;
      }

      function startTextFireworks(now) {
        const pts = buildTextPoints();
        // “描いていく感”を出すために、上から順に軽くソート（同じ高さはランダム）
        pts.sort((a, b) => (a.y - b.y) + rand(-3, 3));
        textQueue = pts;
        nextTextLaunchAt = now + 80;
      }

      // ---- main loop ----
      let last = performance.now();
      let nextAuto = 0;
      let nextTextShow = performance.now() + 1200;

      function frame(now) {
        const dt = clamp(now - last, 0, 34);
        last = now;

        // 背景フェード（残像）
        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = 0.18;
        ctx.fillStyle = "rgb(0,0,0)";
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;

        // 自動打ち上げ
        if (now > nextAuto) {
          if (fireworks.length < 10 && particles.length < 1800) autoLaunch();
          nextAuto = now + rand(450, 950);
        }

        // 文字花火（定期）
        if (now > nextTextShow) {
          startTextFireworks(now);
          nextTextShow = now + 14000; // 14秒おき
        }

        // 文字の点へ順番に小花火
        if (textQueue.length > 0 && now > nextTextLaunchAt) {
          // 1フレームに複数点出して密度を上げる
          const perTick = (W < 420) ? 2 : 3;

          for (let k = 0; k < perTick; k++) {
            if (textQueue.length === 0) break;
            const p = textQueue.shift();

            // 金/青/紫あたりで年末感
            const palette = [48, 210, 280, 330];
            const hue = palette[(Math.random() * palette.length) | 0] + rand(-12, 12);

            launchTo(p.x + rand(-6, 6), p.y + rand(-6, 6), { small: true, hue });
          }

          nextTextLaunchAt = now + rand(18, 32);
        }

        // rockets
        for (let i = fireworks.length - 1; i >= 0; i--) {
          const f = fireworks[i];
          f.step();
          f.draw(ctx);
          if (f.dead) fireworks.splice(i, 1);
        }

        // particles
        ctx.globalCompositeOperation = "lighter";
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.step();
          p.draw(ctx);
          if (p.dead || p.y > H + 60) particles.splice(i, 1);
        }
        ctx.globalCompositeOperation = "source-over";

        requestAnimationFrame(frame);
      }

      // 初期背景を黒で塗る
      ctx.fillStyle = "rgb(0,0,0)";
      ctx.fillRect(0, 0, W, H);

      requestAnimationFrame(frame);
    })();
  </script>
</body>
</html>
