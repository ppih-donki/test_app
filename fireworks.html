<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="robots" content="noindex,nofollow" />
  <title>Fireworks + Text Fireworks</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    .hud {
      position: fixed;
      left: 12px;
      bottom: 12px;
      color: rgba(255,255,255,0.78);
      font-size: 12px;
      line-height: 1.45;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 10px;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      pointer-events: none;
    }
    .hud strong { color: rgba(255,255,255,0.95); }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hud">
    <strong>花火</strong><br />
    ・自動で打ち上げ<br />
    ・タップ/クリックでも発射<br />
    ・文字花火は必ず定期表示（2026 / Happy New Year）
  </div>

  <script>
    (() => {
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d", { alpha: false });

      let W = 0, H = 0, DPR = 1;

      function resize() {
        DPR = Math.min(2, window.devicePixelRatio || 1);
        W = Math.floor(window.innerWidth);
        H = Math.floor(window.innerHeight);
        canvas.width = Math.floor(W * DPR);
        canvas.height = Math.floor(H * DPR);
        canvas.style.width = W + "px";
        canvas.style.height = H + "px";
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        ctx.imageSmoothingEnabled = true;

        textFX.rebuild(); // 文字点群を作り直して確実表示
      }
      window.addEventListener("resize", resize, { passive: true });

      // ---- util ----
      const rand = (a, b) => a + Math.random() * (b - a);
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);

      // ---- physics / tuning ----
      const GRAVITY = 0.075;
      const AIR_DRAG = 0.985;
      const ROCKET_DRAG = 0.992;

      // ---- systems ----
      const fireworks = [];
      const particles = [];

      class Particle {
        constructor(x, y, vx, vy, hue, life, size, glow) {
          this.x = x; this.y = y;
          this.vx = vx; this.vy = vy;
          this.hue = hue;
          this.life = life;
          this.maxLife = life;
          this.size = size;
          this.glow = glow;
          this.twinkle = Math.random() < 0.35;
        }
        step() {
          this.vx *= AIR_DRAG;
          this.vy = this.vy * AIR_DRAG + GRAVITY;
          this.x += this.vx;
          this.y += this.vy;
          this.life -= 1;
        }
        draw(ctx) {
          const t = this.life / this.maxLife;
          const alpha = clamp(t, 0, 1);
          const flicker = this.twinkle ? (0.75 + 0.25 * Math.sin((this.maxLife - this.life) * 0.35)) : 1.0;

          ctx.globalAlpha = alpha * flicker;
          ctx.fillStyle = `hsla(${this.hue}, 100%, 60%, 1)`;

          if (this.glow) {
            ctx.shadowBlur = 12;
            ctx.shadowColor = `hsla(${this.hue}, 100%, 60%, 1)`;
          } else {
            ctx.shadowBlur = 0;
          }

          ctx.beginPath();
          ctx.arc(this.x, this.y, Math.max(0.7, this.size), 0, Math.PI * 2);
          ctx.fill();

          ctx.shadowBlur = 0;
          ctx.globalAlpha = 1;
        }
        get dead() { return this.life <= 0; }
      }

      class Firework {
        constructor(sx, sy, tx, ty) {
          this.sx = sx; this.sy = sy;
          this.x = sx; this.y = sy;
          this.tx = tx; this.ty = ty;

          const angle = Math.atan2(ty - sy, tx - sx);
          const d = dist(sx, sy, tx, ty);
          const speed = clamp(d / 18, 10, 22);

          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed;

          this.hue = rand(0, 360);
          this.trail = [];
          this.trailMax = 14;
          this.exploded = false;
        }

        explode() {
          this.exploded = true;

          const count = Math.floor(rand(70, 140));
          const baseHue = this.hue;
          const ring = Math.random() < 0.35;
          const chrys = Math.random() < 0.40;
          const crackle = Math.random() < 0.30;

          for (let i = 0; i < count; i++) {
            const a = ring ? (i / count) * Math.PI * 2 : rand(0, Math.PI * 2);
            const sp = chrys ? rand(2.8, 6.8) : rand(2.2, 7.6);

            const vx = Math.cos(a) * sp * rand(0.85, 1.15);
            const vy = Math.sin(a) * sp * rand(0.85, 1.15);
            const hue = (baseHue + rand(-18, 18) + (Math.random() < 0.15 ? 60 : 0)) % 360;

            const life = Math.floor(rand(45, 95));
            const size = rand(1.1, 2.2);
            particles.push(new Particle(this.x, this.y, vx, vy, hue, life, size, true));

            if (crackle && Math.random() < 0.18) {
              const vx2 = vx * rand(0.2, 0.55) + rand(-0.6, 0.6);
              const vy2 = vy * rand(0.2, 0.55) + rand(-0.6, 0.6);
              particles.push(new Particle(this.x, this.y, vx2, vy2, hue, Math.floor(rand(18, 32)), rand(0.8, 1.4), false));
            }
          }
        }

        step() {
          this.trail.push({ x: this.x, y: this.y });
          if (this.trail.length > this.trailMax) this.trail.shift();

          this.vx *= ROCKET_DRAG;
          this.vy = this.vy * ROCKET_DRAG - 0.015;
          this.x += this.vx;
          this.y += this.vy;

          const reached = dist(this.x, this.y, this.tx, this.ty) < 18;
          const peaked = this.vy >= -0.5 && this.y < this.sy - 120;

          if (!this.exploded && (reached || peaked)) this.explode();
        }

        draw(ctx) {
          ctx.save();
          ctx.globalCompositeOperation = "lighter";

          for (let i = 0; i < this.trail.length; i++) {
            const p = this.trail[i];
            const t = i / this.trail.length;
            ctx.globalAlpha = (0.05 + 0.35 * t);
            ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, 1)`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 1.2 + 1.6 * t, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.globalAlpha = 1;
          ctx.shadowBlur = 18;
          ctx.shadowColor = `hsla(${this.hue}, 100%, 70%, 1)`;
          ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, 1)`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, 2.2, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }

        get dead() { return this.exploded; }
      }

      function launchTo(x, y) {
        const sx = rand(W * 0.2, W * 0.8);
        const sy = H + 10;
        const tx = clamp(x, 20, W - 20);
        const ty = clamp(y, 40, H * 0.80);
        fireworks.push(new Firework(sx, sy, tx, ty));
      }

      function autoLaunch() {
        const x = rand(W * 0.15, W * 0.85);
        const y = rand(H * 0.12, H * 0.55);
        launchTo(x, y);
      }

      // ---- input ----
      function pointerPos(e) {
        if (e.touches && e.touches[0]) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        if (e.changedTouches && e.changedTouches[0]) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
        return { x: e.clientX, y: e.clientY };
      }
      const onDown = (e) => {
        e.preventDefault();
        const p = pointerPos(e);
        const burst = Math.random() < 0.35 ? 2 : 1;
        for (let i = 0; i < burst; i++) {
          launchTo(p.x + rand(-40, 40), p.y + rand(-30, 30));
        }
        // タップで文字花火を強制発動（確実に見せたい時用）
        textFX.forceStart(performance.now());
      };
      canvas.addEventListener("mousedown", onDown);
      canvas.addEventListener("touchstart", onDown, { passive: false });

      // =========================================================
      // TEXT FIREWORKS (Guaranteed)
      // 文字は「点群を毎フレーム必ず描く」＝必ず見える
      // =========================================================
      const textFX = (() => {
        const off = document.createElement("canvas");
        const offCtx = off.getContext("2d");

        let points = [];
        let isActive = false;
        let startAt = 0;

        // 表示周期（必ず出す）
        const PERIOD_MS = 15000;   // 15秒おき
        const SHOW_MS   = 5200;    // 5.2秒表示（読める長さ）
        let nextAutoAt = performance.now() + 1200; // 最初はすぐ

        function rebuild() {
          if (!W || !H) return;

          off.width = W;
          off.height = H;
          offCtx.clearRect(0, 0, W, H);

          // 文字位置
          const y1 = H * 0.26;
          const y2 = H * 0.40;

          // フォント（太く）
          const size1 = clamp(H * 0.20, 72, 240);
          const size2 = clamp(H * 0.085, 28, 96);

          offCtx.textAlign = "center";
          offCtx.textBaseline = "middle";
          offCtx.fillStyle = "rgba(255,255,255,1)";

          offCtx.font = `900 ${Math.floor(size1)}px system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif`;
          offCtx.fillText("2026", W / 2, y1);

          offCtx.font = `900 ${Math.floor(size2)}px system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif`;
          offCtx.fillText("Happy New Year", W / 2, y2);

          const img = offCtx.getImageData(0, 0, W, H).data;

          // 端末に合わせて密度を調整（多いほどくっきり）
          // ただし重くならないよう上限を持つ
          let step = (W < 420) ? 4 : 3;

          const raw = [];
          for (let y = 0; y < H; y += step) {
            for (let x = 0; x < W; x += step) {
              const a = img[(y * W + x) * 4 + 3];
              if (a > 160) raw.push({ x, y });
            }
          }

          // 上限（ここを上げるほどさらにくっきり。ただし負荷増）
          const maxPoints = (W < 420) ? 1400 : 2200;
          if (raw.length > maxPoints) {
            // ランダム抽出すると輪郭が欠けやすいので、
            // “規則的に間引く”ことで全体を維持
            const ratio = raw.length / maxPoints;
            points = [];
            for (let i = 0; i < raw.length; i += ratio) {
              points.push(raw[Math.floor(i)]);
            }
          } else {
            points = raw;
          }

          // 点ごとに色・位相を持たせる（キラつき）
          const palette = [48, 210, 280, 330]; // 金/青/紫/ピンク
          for (let i = 0; i < points.length; i++) {
            const hue = palette[(Math.random() * palette.length) | 0] + rand(-10, 10);
            points[i].hue = hue;
            points[i].phase = rand(0, Math.PI * 2);
            points[i].tw = Math.random() < 0.65;
          }
        }

        function forceStart(now) {
          startAt = now;
          isActive = true;
          nextAutoAt = now + PERIOD_MS; // 次回は周期で
        }

        function tick(now) {
          if (now >= nextAutoAt) {
            // 必ず再生開始
            startAt = now;
            isActive = true;
            nextAutoAt = now + PERIOD_MS;
          }
          if (isActive && (now - startAt) > SHOW_MS) {
            isActive = false;
          }
        }

        function draw(now) {
          if (!isActive || points.length === 0) return;

          // 文字表示中はフェードを弱くして読みやすくするため、
          // 背景側の処理で参照できるようにフラグを返す
          // （ここでは描画のみ）
          ctx.save();
          ctx.globalCompositeOperation = "lighter";

          // 表示開始直後〜終了に向けて少しだけフェード（でも必ず見える）
          const t = clamp((now - startAt) / SHOW_MS, 0, 1);
          const baseA = 0.95 - 0.15 * t; // 0.95 -> 0.80

          // 点のサイズ（見えない問題の根本：小さすぎると消える）
          const r = (W < 420) ? 1.7 : 1.9;

          // まとめ描画（高輝度・強いグロー）
          for (let i = 0; i < points.length; i++) {
            const p = points[i];
            const pulse = p.tw ? (0.72 + 0.28 * Math.sin(now * 0.010 + p.phase)) : 1.0;

            ctx.globalAlpha = baseA * pulse;

            ctx.shadowBlur = 26;
            ctx.shadowColor = `hsla(${p.hue}, 100%, 65%, 1)`;
            ctx.fillStyle = `hsla(${p.hue}, 100%, 65%, 1)`;

            // 点（文字の輪郭）
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();

            // 小さなスパーク（花火っぽさ：輪郭は崩さない）
            if ((i & 31) === 0) { // 32点に1回程度
              ctx.globalAlpha = baseA * 0.55 * pulse;
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(p.x - 3, p.y);
              ctx.lineTo(p.x + 3, p.y);
              ctx.moveTo(p.x, p.y - 3);
              ctx.lineTo(p.x, p.y + 3);
              ctx.strokeStyle = `hsla(${p.hue}, 100%, 70%, 1)`;
              ctx.stroke();
            }
          }

          ctx.shadowBlur = 0;
          ctx.globalAlpha = 1;
          ctx.restore();

          // “花火”感を追加：文字の周りに控えめに通常花火を1発
          if ((now - startAt) < 120) {
            // 表示開始の瞬間にだけ、上部へ1発
            const x = W / 2 + rand(-W * 0.12, W * 0.12);
            const y = H * 0.18 + rand(-20, 20);
            launchTo(x, y);
          }
        }

        function isShowing() { return isActive; }

        return { rebuild, forceStart, tick, draw, isShowing };
      })();

      // 初期化
      resize();

      // ---- main loop ----
      let last = performance.now();
      let nextAuto = 0;

      function frame(now) {
        const dt = clamp(now - last, 0, 34);
        last = now;

        // 文字花火の状態更新（必ず周期で発動）
        textFX.tick(now);

        // 背景フェード（文字表示中は弱めて視認性を保証）
        const fadeAlpha = textFX.isShowing() ? 0.10 : 0.18;

        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = fadeAlpha;
        ctx.fillStyle = "rgb(0,0,0)";
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;

        // 通常の自動花火（文字表示中は控えめに）
        if (now > nextAuto) {
          const maxFw = textFX.isShowing() ? 6 : 10;
          if (fireworks.length < maxFw && particles.length < 1800) autoLaunch();
          nextAuto = now + rand(450, 950);
        }

        // rockets
        for (let i = fireworks.length - 1; i >= 0; i--) {
          const f = fireworks[i];
          f.step();
          f.draw(ctx);
          if (f.dead) fireworks.splice(i, 1);
        }

        // particles
        ctx.globalCompositeOperation = "lighter";
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.step();
          p.draw(ctx);
          if (p.dead || p.y > H + 60) particles.splice(i, 1);
        }
        ctx.globalCompositeOperation = "source-over";

        // 文字花火（ここが“保証描画”）
        textFX.draw(now);

        requestAnimationFrame(frame);
      }

      // 初期背景
      ctx.fillStyle = "rgb(0,0,0)";
      ctx.fillRect(0, 0, W, H);

      requestAnimationFrame(frame);
    })();
  </script>
</body>
</html>
