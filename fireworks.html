<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="robots" content="noindex,nofollow" />
  <title>Canvas Fireworks</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    .hud {
      position: fixed;
      left: 12px;
      bottom: 12px;
      color: rgba(255,255,255,0.75);
      font-size: 12px;
      line-height: 1.4;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 10px;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      pointer-events: none;
    }
    .hud strong { color: rgba(255,255,255,0.95); }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hud">
    <strong>花火</strong><br />
    ・自動で打ち上げ<br />
    ・画面タップ/クリックでも発射
  </div>

  <script>
    (() => {
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d", { alpha: false });

      let W = 0, H = 0, DPR = 1;

      function resize() {
        DPR = Math.min(2, window.devicePixelRatio || 1);
        W = Math.floor(window.innerWidth);
        H = Math.floor(window.innerHeight);
        canvas.width = Math.floor(W * DPR);
        canvas.height = Math.floor(H * DPR);
        canvas.style.width = W + "px";
        canvas.style.height = H + "px";
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        ctx.imageSmoothingEnabled = true;
      }
      window.addEventListener("resize", resize, { passive: true });
      resize();

      // ---- util ----
      const rand = (a, b) => a + Math.random() * (b - a);
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);

      // ---- physics / tuning ----
      const GRAVITY = 0.075;
      const AIR_DRAG = 0.985;
      const ROCKET_DRAG = 0.992;

      // ---- particle systems ----
      const fireworks = [];
      const particles = [];

      class Particle {
        constructor(x, y, vx, vy, hue, life, size, glow) {
          this.x = x; this.y = y;
          this.vx = vx; this.vy = vy;
          this.hue = hue;
          this.life = life;
          this.maxLife = life;
          this.size = size;
          this.glow = glow;
          this.twinkle = Math.random() < 0.35;
        }
        step() {
          this.vx *= AIR_DRAG;
          this.vy = this.vy * AIR_DRAG + GRAVITY;
          this.x += this.vx;
          this.y += this.vy;
          this.life -= 1;
        }
        draw(ctx) {
          const t = this.life / this.maxLife;
          const alpha = clamp(t, 0, 1);
          const flicker = this.twinkle ? (0.75 + 0.25 * Math.sin((this.maxLife - this.life) * 0.35)) : 1.0;

          ctx.globalAlpha = alpha * flicker;
          ctx.fillStyle = `hsla(${this.hue}, 100%, 60%, 1)`;

          if (this.glow) {
            ctx.shadowBlur = 12;
            ctx.shadowColor = `hsla(${this.hue}, 100%, 60%, 1)`;
          } else {
            ctx.shadowBlur = 0;
          }

          ctx.beginPath();
          ctx.arc(this.x, this.y, Math.max(0.7, this.size), 0, Math.PI * 2);
          ctx.fill();

          ctx.shadowBlur = 0;
          ctx.globalAlpha = 1;
        }
        get dead() { return this.life <= 0; }
      }

      class Firework {
        constructor(sx, sy, tx, ty) {
          this.sx = sx; this.sy = sy;
          this.x = sx; this.y = sy;
          this.tx = tx; this.ty = ty;

          const angle = Math.atan2(ty - sy, tx - sx);
          const d = dist(sx, sy, tx, ty);

          // 速さは距離で少し変える
          const speed = clamp(d / 18, 10, 22);

          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed;

          this.hue = rand(0, 360);
          this.trail = [];
          this.trailMax = 14;
          this.exploded = false;
        }

        explode() {
          this.exploded = true;

          const count = Math.floor(rand(70, 140));
          const baseHue = this.hue;
          const ring = Math.random() < 0.35;       // リング状
          const chrys = Math.random() < 0.40;      // 菊花っぽい
          const crackle = Math.random() < 0.30;    // ぱちぱち

          for (let i = 0; i < count; i++) {
            const a = ring ? (i / count) * Math.PI * 2 : rand(0, Math.PI * 2);
            const sp = chrys ? rand(2.8, 6.8) : rand(2.2, 7.6);
            const vx = Math.cos(a) * sp * rand(0.85, 1.15);
            const vy = Math.sin(a) * sp * rand(0.85, 1.15);
            const hue = (baseHue + rand(-18, 18) + (Math.random() < 0.15 ? 60 : 0)) % 360;
            const life = Math.floor(rand(45, 95));
            const size = rand(1.1, 2.2);
            particles.push(new Particle(this.x, this.y, vx, vy, hue, life, size, true));

            if (crackle && Math.random() < 0.18) {
              // 爆発点付近に小さな火花（短命）
              const vx2 = vx * rand(0.2, 0.55) + rand(-0.6, 0.6);
              const vy2 = vy * rand(0.2, 0.55) + rand(-0.6, 0.6);
              particles.push(new Particle(this.x, this.y, vx2, vy2, hue, Math.floor(rand(18, 32)), rand(0.8, 1.4), false));
            }
          }
        }

        step() {
          // 轨跡
          this.trail.push({ x: this.x, y: this.y });
          if (this.trail.length > this.trailMax) this.trail.shift();

          // 移動
          this.vx *= ROCKET_DRAG;
          this.vy = this.vy * ROCKET_DRAG - 0.015; // 少し上向き補正
          this.x += this.vx;
          this.y += this.vy;

          // ターゲット到達 or 上がり切り判定
          const reached = dist(this.x, this.y, this.tx, this.ty) < 18;
          const peaked = this.vy >= -0.5 && this.y < this.sy - 120;

          if (!this.exploded && (reached || peaked)) {
            this.explode();
          }
        }

        draw(ctx) {
          // trail
          ctx.save();
          ctx.globalCompositeOperation = "lighter";

          for (let i = 0; i < this.trail.length; i++) {
            const p = this.trail[i];
            const t = i / this.trail.length;
            ctx.globalAlpha = (0.05 + 0.35 * t);
            ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, 1)`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 1.2 + 1.6 * t, 0, Math.PI * 2);
            ctx.fill();
          }

          // head
          ctx.globalAlpha = 1;
          ctx.shadowBlur = 18;
          ctx.shadowColor = `hsla(${this.hue}, 100%, 70%, 1)`;
          ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, 1)`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, 2.2, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }

        get dead() { return this.exploded; }
      }

      // ---- launch helpers ----
      function launchTo(x, y) {
        const sx = rand(W * 0.2, W * 0.8);
        const sy = H + 10;
        const tx = clamp(x, 20, W - 20);
        const ty = clamp(y, 40, H * 0.75);
        fireworks.push(new Firework(sx, sy, tx, ty));
      }

      function autoLaunch() {
        const x = rand(W * 0.15, W * 0.85);
        const y = rand(H * 0.12, H * 0.55);
        launchTo(x, y);
      }

      // input (tap/click)
      function pointerPos(e) {
        if (e.touches && e.touches[0]) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        if (e.changedTouches && e.changedTouches[0]) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
        return { x: e.clientX, y: e.clientY };
      }

      const onDown = (e) => {
        e.preventDefault();
        const p = pointerPos(e);
        // 連打で複数発
        const burst = Math.random() < 0.35 ? 2 : 1;
        for (let i = 0; i < burst; i++) {
          launchTo(p.x + rand(-40, 40), p.y + rand(-30, 30));
        }
      };

      canvas.addEventListener("mousedown", onDown);
      canvas.addEventListener("touchstart", onDown, { passive: false });

      // ---- main loop ----
      let last = performance.now();
      let acc = 0;
      let nextAuto = 0;

      function frame(now) {
        const dt = clamp(now - last, 0, 34);
        last = now;
        acc += dt;

        // 背景を少し残してフェード（残像）
        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = 0.18;
        ctx.fillStyle = "rgb(0,0,0)";
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;

        // 自動打ち上げ（端末負荷に合わせて間隔ランダム）
        if (now > nextAuto) {
          if (fireworks.length < 10 && particles.length < 1800) autoLaunch();
          nextAuto = now + rand(450, 950);
        }

        // rockets
        for (let i = fireworks.length - 1; i >= 0; i--) {
          const f = fireworks[i];
          f.step();
          f.draw(ctx);
          if (f.dead) fireworks.splice(i, 1);
        }

        // particles
        ctx.globalCompositeOperation = "lighter";
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.step();
          p.draw(ctx);
          if (p.dead || p.y > H + 60) particles.splice(i, 1);
        }
        ctx.globalCompositeOperation = "source-over";

        requestAnimationFrame(frame);
      }

      // 初期背景を黒で塗る
      ctx.fillStyle = "rgb(0,0,0)";
      ctx.fillRect(0, 0, W, H);

      requestAnimationFrame(frame);
    })();
  </script>
</body>
</html>
